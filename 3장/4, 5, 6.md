---


---

<h1 id="노드-내장-객체-알아보기">3.4 노드 내장 객체 알아보기</h1>
<h3 id="global">global</h3>
<p>전역 객체이다.<br>
지금까지 우리가 사용해 왔던 console 객체, require 함수 등이 전부 global 내부 프로퍼티와 메소스들이다. 원래는 global.console.log()인 것이다.</p>
<h3 id="console">console</h3>
<p>앞서 말했듯 global 객체 안에 들어 있는 것들 중 하나이다.<br>
자주 사용하는 console.log 외에도 다양한 메소드들이 있다</p>

<table>
<thead>
<tr>
<th>함수</th>
<th>기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>time(), timeEnd()</td>
<td>대응되어 같은 레이블을 가진 두 메소드 사이의 시간 측정</td>
</tr>
<tr>
<td>log(param)</td>
<td>인자로 받은 내용 표시, 인자를 컴마로 구분하여 한번에 여러 내용 출력 가능</td>
</tr>
<tr>
<td>error(param)</td>
<td>에러 내용을 콘솔에 표시</td>
</tr>
<tr>
<td>dir(객체, 옵션)</td>
<td>객체를 콘솔에 표시할 때 사용. 옵션에는 color, depth 등을 추가할 수 있음</td>
</tr>
<tr>
<td>trace(label)</td>
<td>에러 발생 위치 추적</td>
</tr>
</tbody>
</table><h3 id="타이머">타이머</h3>
<p>타이머 기능을 제공해 주는 global 객체 안의 함수들</p>

<table>
<thead>
<tr>
<th>함수</th>
<th>기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTimeout(CB,millSec)</td>
<td>주어진 밀리초 이후 콜백 함수 실행</td>
</tr>
<tr>
<td>setInterval(CB,millSec)</td>
<td>주어진 밀리초마다 콜백 함수를 반복 실행(첫 실행은 주어진 밀리초 이후)</td>
</tr>
<tr>
<td>setImmediate(CB)</td>
<td>즉시 콜백 함수 실행</td>
</tr>
</tbody>
</table><p>위 콜백 함수들은 모두 아이디를 반환한다. clear를 이용하여 타이머를 취소할 수 있다.</p>

<table>
<thead>
<tr>
<th>함수</th>
<th>기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>clearTimeout(id)</td>
<td>setTimeout 취소</td>
</tr>
<tr>
<td>clearInterval(id)</td>
<td>setInterval 취소</td>
</tr>
<tr>
<td>clearImmediate(id)</td>
<td>setImmediate 취소</td>
</tr>
</tbody>
</table><p>다음과 같이 사용한다.</p>
<pre><code>const timeout = setTimeout( () =&gt; {
	console.log("1.5초 후 실행")
}, 1500);

cleatTimeout(timeout);
</code></pre>
<h3 id="filename-__dirname">__filename, __dirname</h3>
<p>경로에 대한 정보 제공.<br>
filename : 현재 파일명, dirname : 파일 경로<br>
OS마다 다른 경로 표기 문제를 해결하기 위해 보통 path모듈과 함께 사용</p>
<h3 id="module-exports">module, exports</h3>
<p>둘 다 모듈을 만들 때 사용한다.<br>
다만 module.exports는 한 번에 대입하고, exports는 하나씩 넣을 수 있다.<br>
<strong>이 때 exports를 사용할 때는 객체만 넣을 수 있다.</strong><br>
함수를 대입하는 경우에는 module.exports를 사용한다.</p>
<blockquote>
<p>사실 그럼 객체 안에 메소드를 넣어서 exports 해도 괜찮지 않나…?</p>
</blockquote>
<h3 id="process">process</h3>
<p>현재 실행되고 있는 노드 프로세스에 대한 정보를 담은 객체.<br>
varsion, arch, platform, pid, uptime, execPath, cwd, cpuUsage 등이 있다.</p>
<h4 id="process.env">process.env</h4>
<p>시스템의 환경 변수를 출력한다.<br>
아이디, 비밀번호 등 중요한 키를 저장하는 공간으로도 사용한다.</p>
<pre><code>const secretId = process.env.SECRET_ID;
const secrteCode = process.env.SECRET_CODE;
</code></pre>
<p>다음과 같이 process의 속성으로 대체하여 사용한다.<br>
이제 env에 직접 ID 와 CODE를 넣으면 되는데, 이때는 <em>dotenv</em>를 사용한다.</p>
<h4 id="process.nexttickcb">process.nextTick(CB)</h4>
<p>이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하게 한다.<br>
<em>Promise</em>의 콜백 함수 또한 다른 콜백들보다 우선시된다.<br>
그래서 process.nextTick()과 Promise를 마이크로테스크 라고 따로 구분지어 부른다.</p>
<h4 id="process.exitcode">process.exit(code)</h4>
<p>실행 중인 노드 프로세스를 종료한다.<br>
code에 0 혹은 1을 넣는다. 0이면 정상종료, 1이면 비정상 종료이다.</p>
<h1 id="노드-내장-모듈-사용하기">3.5 노드 내장 모듈 사용하기</h1>
<p>노드 내장 모듈을 사용하여, 운영체재 정보, 클라이언트가 요청한 주소에 대한 정보 등을 가져올 수 있다.</p>
<h3 id="os">os</h3>
<p>os모듈에는 운영체제의 정보가 담겨있다.<br>
책 94페이지.</p>
<h3 id="path">path</h3>
<p>폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈이다.<br>
경로를 구분하는 방식은 크게 두 가지가 있는데, W(왜 원화모양 못쓰게 해요ㅋㅋ)방식의 윈도우 타입과 /로 구분하는 POSIX 타입이다.</p>

<table>
<thead>
<tr>
<th>프로퍼티 &amp; 함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>sep</td>
<td>경로의 구분자(\ 혹은 /)</td>
</tr>
<tr>
<td>delimeter</td>
<td>환경 변수의 구분자(Win ; , POSIX :)</td>
</tr>
<tr>
<td>dirname(__filename(경로))</td>
<td>파일이 위치한 표시 경로 출략</td>
</tr>
<tr>
<td>extname(경로)</td>
<td>파일의 확장자명 표시</td>
</tr>
<tr>
<td>basename(경로, 확장자)</td>
<td>확장자를 포함한 파일의 이름 표시</td>
</tr>
<tr>
<td>parse(경로)</td>
<td>경로를 root, dir, base, ext, name으로 분리함</td>
</tr>
<tr>
<td>format(객체)</td>
<td>parse한 객체를 파일 경로로 합침</td>
</tr>
<tr>
<td>normalize(경로)</td>
<td>\나/를 여러번 사용한경우 정상 경로로 변환해줌</td>
</tr>
<tr>
<td>isAbsolute(경로)</td>
<td>파일의 경로가 절대경로인지 상대경로인지 boolean 반환</td>
</tr>
<tr>
<td>relative(기준경로, 비교경로</td>
<td>첫 번째 경로에서 두 번째 경로로 가는 법 반환</td>
</tr>
<tr>
<td>join(경로, …)</td>
<td>여러 인자를 넣으면 하나의 경로로 합쳐줌. 상대경로 호환</td>
</tr>
<tr>
<td>resolve(경로, …)</td>
<td>여러 인자를 넣으면 하나의 경로로 합쳐줌</td>
</tr>
</tbody>
</table><h5 id="join-vs-resolve">join vs resolve</h5>
<pre><code>path.join('/a','/b','c');  // 결과 : /a/b/c
path.resolve('/a','/b','c'); //결과 : /b/c
</code></pre>
<h3 id="url">url</h3>
<p>인터넷 주소를 쉽게 조작하도록 도와주는 모듈<br>
WHATWG 방식과 기존 방식이 있다.<br>
WHATWG의 url에는 username, password, origin, searchParams 속성이 존재한다.<br>
기존 노드 방식에서는 위의 속성들이 없고, auth와 query가 있다.<br>
책 99페이지 참고.<br>
WHATWG방식은 주소가 host없이 pathname만 오는 경우 이를 처리할 수 없다.<br>
WHATWG방식은, search부분을 searchParams라는 특수한 객체로 반환하므로 유용하다.</p>
<p>query 같은 문자열보다 searchParams가 더 유용한 이유는 query의 경우 querystring을 한번 더 이용해야 하기 때문이다.</p>
<h3 id="querystring">querystring</h3>
<p>parse(쿼리) : 쿼리부분을 자바스크립트 객체로 분할해준다<br>
stringify(객체):분해된 쿼리객체를 문자열로 다시 조합.</p>
<p>’</p>

